export declare type Ok<T> = {
    ok: true;
    value: T;
};
export declare type Error<T> = {
    ok: false;
    value: T;
};
export declare type Result<TOk, TError> = Ok<TOk> | Error<TError>;
export declare function fallible<TOk, TError>(func: (propagate: <TReturn>(result: Result<TReturn, TError>) => TReturn) => Result<TOk, TError>): Result<TOk, TError>;
export declare type Awaitable<T> = T | PromiseLike<T>;
export declare function asyncFallible<TOk, TError>(func: (propagate: <TReturn>(result: Result<TReturn, TError>) => TReturn) => Awaitable<Result<TOk, TError>>): Promise<Result<TOk, TError>>;
export declare function ok<T extends void>(): Ok<T>;
export declare function ok<T>(value: T): Ok<T>;
export declare function error<T extends void>(): Error<T>;
export declare function error<T>(value: T): Error<T>;
export declare function mapError<TOk, TError, TNewError>(func: (error: TError) => TNewError): (result: Result<TOk, TError>) => Result<TOk, TNewError>;
export declare function tapError<TOk, TError>(func: (error: TError) => void): (result: Result<TOk, TError>) => Result<TOk, TError>;
export declare function catchAnyException<TOk>(func: () => TOk): Result<TOk, unknown>;
export declare function catchGuardedException<TOk, TError>(func: () => TOk, exceptionGuard: (exception: unknown) => exception is TError): Result<TOk, TError>;
export declare function catchExceptionByType<TOk, TError>(func: () => TOk, exceptionType: new (...args: any[]) => TError): Result<TOk, TError>;
export declare function asyncCatchAnyException<TOk>(func: () => Awaitable<TOk>): Promise<Result<TOk, unknown>>;
export declare function asyncCatchGuardedException<TOk, TError>(func: () => Awaitable<TOk>, exceptionGuard: (exception: unknown) => exception is TError): Promise<Result<TOk, TError>>;
export declare function asyncCatchExceptionByType<TOk, TError>(func: () => Awaitable<TOk>, exceptionType: new (...args: any[]) => TError): Promise<Result<TOk, TError>>;
export declare function wrapAnyException<TArgs extends any[], TReturn>(func: (...args: TArgs) => TReturn): (...args: TArgs) => Result<TReturn, unknown>;
export declare function wrapGuardedException<TArgs extends any[], TReturn, TError>(func: (...args: TArgs) => TReturn, exceptionGuard: (exception: unknown) => exception is TError): (...args: TArgs) => Result<TReturn, TError>;
export declare function wrapExceptionByType<TArgs extends any[], TReturn, TError>(func: (...args: TArgs) => TReturn, exceptionType: new (...args: any[]) => TError): (...args: TArgs) => Result<TReturn, TError>;
export declare function asyncWrapAnyException<TArgs extends any[], TReturn>(func: (...args: TArgs) => Awaitable<TReturn>): (...args: TArgs) => Promise<Result<TReturn, unknown>>;
export declare function asyncWrapGuardedException<TArgs extends any[], TReturn, TError>(func: (...args: TArgs) => Awaitable<TReturn>, exceptionGuard: (exception: unknown) => exception is TError): (...args: TArgs) => Promise<Result<TReturn, TError>>;
export declare function asyncWrapExceptionByType<TArgs extends any[], TReturn, TError>(func: (...args: TArgs) => Awaitable<TReturn>, exceptionType: new (...args: any[]) => TError): (...args: TArgs) => Promise<Result<TReturn, TError>>;
